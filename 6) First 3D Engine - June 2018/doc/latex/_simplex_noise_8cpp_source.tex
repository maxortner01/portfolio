\section{Simplex\+Noise.\+cpp}
\label{_simplex_noise_8cpp_source}\index{src/engine/util/\+Simplex\+Noise.\+cpp@{src/engine/util/\+Simplex\+Noise.\+cpp}}

\begin{DoxyCode}
00001 
00027 \textcolor{preprocessor}{#include "SimplexNoise.h"}
00028 
00029 \textcolor{preprocessor}{#include <cstdint>}  \textcolor{comment}{// int32\_t/uint8\_t}
00030 
00045 \textcolor{keyword}{static} \textcolor{keyword}{inline} int32\_t fastfloor(\textcolor{keywordtype}{float} fp) \{
00046     int32\_t i = \textcolor{keyword}{static\_cast<}int32\_t\textcolor{keyword}{>}(fp);
00047     \textcolor{keywordflow}{return} (fp < i) ? (i - 1) : (i);
00048 \}
00049 
00071 \textcolor{keyword}{static} \textcolor{keyword}{const} uint8\_t perm[256] = \{
00072     151, 160, 137, 91, 90, 15,
00073     131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
00074     190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
00075     88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
00076     77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
00077     102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
00078     135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
00079     5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
00080     223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
00081     129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
00082     251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
00083     49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
00084     138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
00085 \};
00086 
00099 \textcolor{keyword}{static} \textcolor{keyword}{inline} uint8\_t hash(int32\_t i) \{
00100     \textcolor{keywordflow}{return} perm[\textcolor{keyword}{static\_cast<}uint8\_t\textcolor{keyword}{>}(i)];
00101 \}
00102 
00103 \textcolor{comment}{/* NOTE Gradient table to test if lookup-table are more efficient than calculs}
00104 \textcolor{comment}{static const float gradients1D[16] = \{}
00105 \textcolor{comment}{        -8.f, -7.f, -6.f, -5.f, -4.f, -3.f, -2.f, -1.f,}
00106 \textcolor{comment}{         1.f,  2.f,  3.f,  4.f,  5.f,  6.f,  7.f,  8.f}
00107 \textcolor{comment}{\};}
00108 \textcolor{comment}{*/}
00109 
00125 \textcolor{keyword}{static} \textcolor{keywordtype}{float} grad(int32\_t hash, \textcolor{keywordtype}{float} x) \{
00126     \textcolor{keyword}{const} int32\_t h = hash & 0x0F;  \textcolor{comment}{// Convert low 4 bits of hash code}
00127     \textcolor{keywordtype}{float} grad = 1.0f + (h & 7);    \textcolor{comment}{// Gradient value 1.0, 2.0, ..., 8.0}
00128     \textcolor{keywordflow}{if} ((h & 8) != 0) grad = -grad; \textcolor{comment}{// Set a random sign for the gradient}
00129 \textcolor{comment}{//  float grad = gradients1D[h];    // NOTE : Test of Gradient look-up table instead of the above}
00130     \textcolor{keywordflow}{return} (grad * x);              \textcolor{comment}{// Multiply the gradient with the distance}
00131 \}
00132 
00142 \textcolor{keyword}{static} \textcolor{keywordtype}{float} grad(int32\_t hash, \textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y) \{
00143     \textcolor{keyword}{const} int32\_t h = hash & 0x3F;  \textcolor{comment}{// Convert low 3 bits of hash code}
00144     \textcolor{keyword}{const} \textcolor{keywordtype}{float} u = h < 4 ? x : y;  \textcolor{comment}{// into 8 simple gradient directions,}
00145     \textcolor{keyword}{const} \textcolor{keywordtype}{float} v = h < 4 ? y : x;
00146     \textcolor{keywordflow}{return} ((h & 1) ? -u : u) + ((h & 2) ? -2.0f * v : 2.0f * v); \textcolor{comment}{// and compute the dot product with
       (x,y).}
00147 \}
00148 
00159 \textcolor{keyword}{static} \textcolor{keywordtype}{float} grad(int32\_t hash, \textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z) \{
00160     \textcolor{keywordtype}{int} h = hash & 15;     \textcolor{comment}{// Convert low 4 bits of hash code into 12 simple}
00161     \textcolor{keywordtype}{float} u = h < 8 ? x : y; \textcolor{comment}{// gradient directions, and compute dot product.}
00162     \textcolor{keywordtype}{float} v = h < 4 ? y : h == 12 || h == 14 ? x : z; \textcolor{comment}{// Fix repeats at h = 12 to 15}
00163     \textcolor{keywordflow}{return} ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
00164 \}
00165 
00175 \textcolor{keywordtype}{float} SimplexNoise::noise(\textcolor{keywordtype}{float} x) \{
00176     \textcolor{keywordtype}{float} n0, n1;   \textcolor{comment}{// Noise contributions from the two "corners"}
00177 
00178     \textcolor{comment}{// No need to skew the input space in 1D}
00179 
00180     \textcolor{comment}{// Corners coordinates (nearest integer values):}
00181     int32\_t i0 = fastfloor(x);
00182     int32\_t i1 = i0 + 1;
00183     \textcolor{comment}{// Distances to corners (between 0 and 1):}
00184     \textcolor{keywordtype}{float} x0 = x - i0;
00185     \textcolor{keywordtype}{float} x1 = x0 - 1.0f;
00186 
00187     \textcolor{comment}{// Calculate the contribution from the first corner}
00188     \textcolor{keywordtype}{float} t0 = 1.0f - x0*x0;
00189 \textcolor{comment}{//  if(t0 < 0.0f) t0 = 0.0f; // not possible}
00190     t0 *= t0;
00191     n0 = t0 * t0 * grad(hash(i0), x0);
00192 
00193     \textcolor{comment}{// Calculate the contribution from the second corner}
00194     \textcolor{keywordtype}{float} t1 = 1.0f - x1*x1;
00195 \textcolor{comment}{//  if(t1 < 0.0f) t1 = 0.0f; // not possible}
00196     t1 *= t1;
00197     n1 = t1 * t1 * grad(hash(i1), x1);
00198 
00199     \textcolor{comment}{// The maximum value of this noise is 8*(3/4)^4 = 2.53125}
00200     \textcolor{comment}{// A factor of 0.395 scales to fit exactly within [-1,1]}
00201     \textcolor{keywordflow}{return} 0.395f * (n0 + n1);
00202 \}
00203 
00214 \textcolor{keywordtype}{float} SimplexNoise::noise(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y) \{
00215     \textcolor{keywordtype}{float} n0, n1, n2;   \textcolor{comment}{// Noise contributions from the three corners}
00216 
00217     \textcolor{comment}{// Skewing/Unskewing factors for 2D}
00218     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{float} F2 = 0.366025403f;  \textcolor{comment}{// F2 = (sqrt(3) - 1) / 2}
00219     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{float} G2 = 0.211324865f;  \textcolor{comment}{// G2 = (3 - sqrt(3)) / 6   = F2 / (1 + 2 * K)}
00220 
00221     \textcolor{comment}{// Skew the input space to determine which simplex cell we're in}
00222     \textcolor{keyword}{const} \textcolor{keywordtype}{float} s = (x + y) * F2;  \textcolor{comment}{// Hairy factor for 2D}
00223     \textcolor{keyword}{const} \textcolor{keywordtype}{float} xs = x + s;
00224     \textcolor{keyword}{const} \textcolor{keywordtype}{float} ys = y + s;
00225     \textcolor{keyword}{const} int32\_t i = fastfloor(xs);
00226     \textcolor{keyword}{const} int32\_t j = fastfloor(ys);
00227 
00228     \textcolor{comment}{// Unskew the cell origin back to (x,y) space}
00229     \textcolor{keyword}{const} \textcolor{keywordtype}{float} t = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(i + j) * G2;
00230     \textcolor{keyword}{const} \textcolor{keywordtype}{float} X0 = i - t;
00231     \textcolor{keyword}{const} \textcolor{keywordtype}{float} Y0 = j - t;
00232     \textcolor{keyword}{const} \textcolor{keywordtype}{float} x0 = x - X0;  \textcolor{comment}{// The x,y distances from the cell origin}
00233     \textcolor{keyword}{const} \textcolor{keywordtype}{float} y0 = y - Y0;
00234 
00235     \textcolor{comment}{// For the 2D case, the simplex shape is an equilateral triangle.}
00236     \textcolor{comment}{// Determine which simplex we are in.}
00237     int32\_t i1, j1;  \textcolor{comment}{// Offsets for second (middle) corner of simplex in (i,j) coords}
00238     \textcolor{keywordflow}{if} (x0 > y0) \{   \textcolor{comment}{// lower triangle, XY order: (0,0)->(1,0)->(1,1)}
00239         i1 = 1;
00240         j1 = 0;
00241     \} \textcolor{keywordflow}{else} \{   \textcolor{comment}{// upper triangle, YX order: (0,0)->(0,1)->(1,1)}
00242         i1 = 0;
00243         j1 = 1;
00244     \}
00245 
00246     \textcolor{comment}{// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and}
00247     \textcolor{comment}{// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where}
00248     \textcolor{comment}{// c = (3-sqrt(3))/6}
00249 
00250     \textcolor{keyword}{const} \textcolor{keywordtype}{float} x1 = x0 - i1 + G2;            \textcolor{comment}{// Offsets for middle corner in (x,y) unskewed coords}
00251     \textcolor{keyword}{const} \textcolor{keywordtype}{float} y1 = y0 - j1 + G2;
00252     \textcolor{keyword}{const} \textcolor{keywordtype}{float} x2 = x0 - 1.0f + 2.0f * G2;   \textcolor{comment}{// Offsets for last corner in (x,y) unskewed coords}
00253     \textcolor{keyword}{const} \textcolor{keywordtype}{float} y2 = y0 - 1.0f + 2.0f * G2;
00254 
00255     \textcolor{comment}{// Work out the hashed gradient indices of the three simplex corners}
00256     \textcolor{keyword}{const} \textcolor{keywordtype}{int} gi0 = hash(i + hash(j));
00257     \textcolor{keyword}{const} \textcolor{keywordtype}{int} gi1 = hash(i + i1 + hash(j + j1));
00258     \textcolor{keyword}{const} \textcolor{keywordtype}{int} gi2 = hash(i + 1 + hash(j + 1));
00259 
00260     \textcolor{comment}{// Calculate the contribution from the first corner}
00261     \textcolor{keywordtype}{float} t0 = 0.5f - x0*x0 - y0*y0;
00262     \textcolor{keywordflow}{if} (t0 < 0.0f) \{
00263         n0 = 0.0f;
00264     \} \textcolor{keywordflow}{else} \{
00265         t0 *= t0;
00266         n0 = t0 * t0 * grad(gi0, x0, y0);
00267     \}
00268 
00269     \textcolor{comment}{// Calculate the contribution from the second corner}
00270     \textcolor{keywordtype}{float} t1 = 0.5f - x1*x1 - y1*y1;
00271     \textcolor{keywordflow}{if} (t1 < 0.0f) \{
00272         n1 = 0.0f;
00273     \} \textcolor{keywordflow}{else} \{
00274         t1 *= t1;
00275         n1 = t1 * t1 * grad(gi1, x1, y1);
00276     \}
00277 
00278     \textcolor{comment}{// Calculate the contribution from the third corner}
00279     \textcolor{keywordtype}{float} t2 = 0.5f - x2*x2 - y2*y2;
00280     \textcolor{keywordflow}{if} (t2 < 0.0f) \{
00281         n2 = 0.0f;
00282     \} \textcolor{keywordflow}{else} \{
00283         t2 *= t2;
00284         n2 = t2 * t2 * grad(gi2, x2, y2);
00285     \}
00286 
00287     \textcolor{comment}{// Add contributions from each corner to get the final noise value.}
00288     \textcolor{comment}{// The result is scaled to return values in the interval [-1,1].}
00289     \textcolor{keywordflow}{return} 45.23065f * (n0 + n1 + n2);
00290 \}
00291 
00292 
00302 \textcolor{keywordtype}{float} SimplexNoise::noise(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z) \{
00303     \textcolor{keywordtype}{float} n0, n1, n2, n3; \textcolor{comment}{// Noise contributions from the four corners}
00304 
00305     \textcolor{comment}{// Skewing/Unskewing factors for 3D}
00306     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{float} F3 = 1.0f / 3.0f;
00307     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{float} G3 = 1.0f / 6.0f;
00308 
00309     \textcolor{comment}{// Skew the input space to determine which simplex cell we're in}
00310     \textcolor{keywordtype}{float} s = (x + y + z) * F3; \textcolor{comment}{// Very nice and simple skew factor for 3D}
00311     \textcolor{keywordtype}{int} i = fastfloor(x + s);
00312     \textcolor{keywordtype}{int} j = fastfloor(y + s);
00313     \textcolor{keywordtype}{int} k = fastfloor(z + s);
00314     \textcolor{keywordtype}{float} t = (i + j + k) * G3;
00315     \textcolor{keywordtype}{float} X0 = i - t; \textcolor{comment}{// Unskew the cell origin back to (x,y,z) space}
00316     \textcolor{keywordtype}{float} Y0 = j - t;
00317     \textcolor{keywordtype}{float} Z0 = k - t;
00318     \textcolor{keywordtype}{float} x0 = x - X0; \textcolor{comment}{// The x,y,z distances from the cell origin}
00319     \textcolor{keywordtype}{float} y0 = y - Y0;
00320     \textcolor{keywordtype}{float} z0 = z - Z0;
00321 
00322     \textcolor{comment}{// For the 3D case, the simplex shape is a slightly irregular tetrahedron.}
00323     \textcolor{comment}{// Determine which simplex we are in.}
00324     \textcolor{keywordtype}{int} i1, j1, k1; \textcolor{comment}{// Offsets for second corner of simplex in (i,j,k) coords}
00325     \textcolor{keywordtype}{int} i2, j2, k2; \textcolor{comment}{// Offsets for third corner of simplex in (i,j,k) coords}
00326     \textcolor{keywordflow}{if} (x0 >= y0) \{
00327         \textcolor{keywordflow}{if} (y0 >= z0) \{
00328             i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; \textcolor{comment}{// X Y Z order}
00329         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x0 >= z0) \{
00330             i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; \textcolor{comment}{// X Z Y order}
00331         \} \textcolor{keywordflow}{else} \{
00332             i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; \textcolor{comment}{// Z X Y order}
00333         \}
00334     \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// x0<y0}
00335         \textcolor{keywordflow}{if} (y0 < z0) \{
00336             i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; \textcolor{comment}{// Z Y X order}
00337         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (x0 < z0) \{
00338             i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; \textcolor{comment}{// Y Z X order}
00339         \} \textcolor{keywordflow}{else} \{
00340             i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; \textcolor{comment}{// Y X Z order}
00341         \}
00342     \}
00343 
00344     \textcolor{comment}{// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),}
00345     \textcolor{comment}{// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and}
00346     \textcolor{comment}{// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where}
00347     \textcolor{comment}{// c = 1/6.}
00348     \textcolor{keywordtype}{float} x1 = x0 - i1 + G3; \textcolor{comment}{// Offsets for second corner in (x,y,z) coords}
00349     \textcolor{keywordtype}{float} y1 = y0 - j1 + G3;
00350     \textcolor{keywordtype}{float} z1 = z0 - k1 + G3;
00351     \textcolor{keywordtype}{float} x2 = x0 - i2 + 2.0f * G3; \textcolor{comment}{// Offsets for third corner in (x,y,z) coords}
00352     \textcolor{keywordtype}{float} y2 = y0 - j2 + 2.0f * G3;
00353     \textcolor{keywordtype}{float} z2 = z0 - k2 + 2.0f * G3;
00354     \textcolor{keywordtype}{float} x3 = x0 - 1.0f + 3.0f * G3; \textcolor{comment}{// Offsets for last corner in (x,y,z) coords}
00355     \textcolor{keywordtype}{float} y3 = y0 - 1.0f + 3.0f * G3;
00356     \textcolor{keywordtype}{float} z3 = z0 - 1.0f + 3.0f * G3;
00357 
00358     \textcolor{comment}{// Work out the hashed gradient indices of the four simplex corners}
00359     \textcolor{keywordtype}{int} gi0 = hash(i + hash(j + hash(k)));
00360     \textcolor{keywordtype}{int} gi1 = hash(i + i1 + hash(j + j1 + hash(k + k1)));
00361     \textcolor{keywordtype}{int} gi2 = hash(i + i2 + hash(j + j2 + hash(k + k2)));
00362     \textcolor{keywordtype}{int} gi3 = hash(i + 1 + hash(j + 1 + hash(k + 1)));
00363 
00364     \textcolor{comment}{// Calculate the contribution from the four corners}
00365     \textcolor{keywordtype}{float} t0 = 0.6f - x0*x0 - y0*y0 - z0*z0;
00366     \textcolor{keywordflow}{if} (t0 < 0) \{
00367         n0 = 0.0;
00368     \} \textcolor{keywordflow}{else} \{
00369         t0 *= t0;
00370         n0 = t0 * t0 * grad(gi0, x0, y0, z0);
00371     \}
00372     \textcolor{keywordtype}{float} t1 = 0.6f - x1*x1 - y1*y1 - z1*z1;
00373     \textcolor{keywordflow}{if} (t1 < 0) \{
00374         n1 = 0.0;
00375     \} \textcolor{keywordflow}{else} \{
00376         t1 *= t1;
00377         n1 = t1 * t1 * grad(gi1, x1, y1, z1);
00378     \}
00379     \textcolor{keywordtype}{float} t2 = 0.6f - x2*x2 - y2*y2 - z2*z2;
00380     \textcolor{keywordflow}{if} (t2 < 0) \{
00381         n2 = 0.0;
00382     \} \textcolor{keywordflow}{else} \{
00383         t2 *= t2;
00384         n2 = t2 * t2 * grad(gi2, x2, y2, z2);
00385     \}
00386     \textcolor{keywordtype}{float} t3 = 0.6f - x3*x3 - y3*y3 - z3*z3;
00387     \textcolor{keywordflow}{if} (t3 < 0) \{
00388         n3 = 0.0;
00389     \} \textcolor{keywordflow}{else} \{
00390         t3 *= t3;
00391         n3 = t3 * t3 * grad(gi3, x3, y3, z3);
00392     \}
00393     \textcolor{comment}{// Add contributions from each corner to get the final noise value.}
00394     \textcolor{comment}{// The result is scaled to stay just inside [-1,1]}
00395     \textcolor{keywordflow}{return} 32.0f*(n0 + n1 + n2 + n3);
00396 \}
00397 
00398 
00407 \textcolor{keywordtype}{float} SimplexNoise::fractal(\textcolor{keywordtype}{size\_t} octaves, \textcolor{keywordtype}{float} x)\textcolor{keyword}{ const }\{
00408     \textcolor{keywordtype}{float} output    = 0.f;
00409     \textcolor{keywordtype}{float} denom     = 0.f;
00410     \textcolor{keywordtype}{float} frequency = mFrequency;
00411     \textcolor{keywordtype}{float} amplitude = mAmplitude;
00412 
00413     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < octaves; i++) \{
00414         output += (amplitude * noise(x * frequency));
00415         denom += amplitude;
00416 
00417         frequency *= mLacunarity;
00418         amplitude *= mPersistence;
00419     \}
00420 
00421     \textcolor{keywordflow}{return} (output / denom);
00422 \}
00423 
00433 \textcolor{keywordtype}{float} SimplexNoise::fractal(\textcolor{keywordtype}{size\_t} octaves, \textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y)\textcolor{keyword}{ const }\{
00434     \textcolor{keywordtype}{float} output = 0.f;
00435     \textcolor{keywordtype}{float} denom  = 0.f;
00436     \textcolor{keywordtype}{float} frequency = mFrequency;
00437     \textcolor{keywordtype}{float} amplitude = mAmplitude;
00438 
00439     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < octaves; i++) \{
00440         output += (amplitude * noise(x * frequency, y * frequency));
00441         denom += amplitude;
00442 
00443         frequency *= mLacunarity;
00444         amplitude *= mPersistence;
00445     \}
00446 
00447     \textcolor{keywordflow}{return} (output / denom);
00448 \}
00449 
00460 \textcolor{keywordtype}{float} SimplexNoise::fractal(\textcolor{keywordtype}{size\_t} octaves, \textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z)\textcolor{keyword}{ const }\{
00461     \textcolor{keywordtype}{float} output = 0.f;
00462     \textcolor{keywordtype}{float} denom  = 0.f;
00463     \textcolor{keywordtype}{float} frequency = mFrequency;
00464     \textcolor{keywordtype}{float} amplitude = mAmplitude;
00465 
00466     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < octaves; i++) \{
00467         output += (amplitude * noise(x * frequency, y * frequency, z * frequency));
00468         denom += amplitude;
00469 
00470         frequency *= mLacunarity;
00471         amplitude *= mPersistence;
00472     \}
00473 
00474     \textcolor{keywordflow}{return} (output / denom);
00475 \}
\end{DoxyCode}
