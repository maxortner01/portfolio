\section{terrain.\+cpp}
\label{terrain_8cpp_source}\index{src/engine/entities/terrain.\+cpp@{src/engine/entities/terrain.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include "terrain.h"}
00002 
00003 \textcolor{comment}{/* <---------- STRUCT: TERRAIN ----------> */}
00004 
00005 Terrain::Sector::Sector(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, Shader* s, Camera* c) \{
00006     shader = s; camera = c;
00007 
00008     generate(x, y);
00009 \}
00010 
00011 \textcolor{keywordtype}{void} Terrain::Sector::generate(\textcolor{keyword}{const} \textcolor{keywordtype}{float} x, \textcolor{keyword}{const} \textcolor{keywordtype}{float} z) \{
00012     std::vector<float> vertices;
00013 
00014     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} Z = 0; Z < SECTOR\_DEPTH; Z++) \{
00015         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} X = 0; X < SECTOR\_WIDTH; X++) \{
00016             vec2 location = vec2(x + X, z + Z);
00017 
00018             \textcolor{comment}{//Get corner values from simplex noise function}
00019             std::vector<float> corners = \{
00020                 Terrain::getval(location.x,     location.y + 1), 
00021                 Terrain::getval(location.x + 1, location.y + 1),
00022                 Terrain::getval(location.x,     location.y), 
00023                 Terrain::getval(location.x + 1, location.y)
00024             \};
00025 
00026             \textcolor{comment}{//Create tile vertices using corner values}
00027             std::vector<float> tile = VERT::getTile(
00028                 corners[0], corners[1], corners[2], corners[3]);
00029 
00030             \textcolor{comment}{//Transform current tile by position in sector}
00031             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} v = 0; v < tile.size() / 3; v++) \{
00032                 \textcolor{keywordtype}{int} index        = v * 3;
00033                 tile[index]     += location.x;
00034                 tile[index + 2] += location.y;
00035 
00036                 vertices.push\_back(tile[index]);
00037                 vertices.push\_back(tile[index + 1]);
00038                 vertices.push\_back(tile[index + 2]);
00039             \}
00040         \}
00041     \}
00042 
00043     model = \textcolor{keyword}{new} Model(vertices, std::vector<float>\{\});
00044 \}
00045 
00046 \textcolor{keywordtype}{void} Terrain::Sector::render()\textcolor{keyword}{ const }\{
00047     model->render(shader, mat4(1.0), camera);
00048 \}
00049 
00050 Terrain::Sector::~Sector() \{
00051     \textcolor{keyword}{delete} model;
00052 \}
00053 
00054 \textcolor{comment}{/* <---------- CLASS: TERRAIN ----------> */}
00055 
00056 \textcolor{keywordtype}{float} Terrain::getval(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y) \{
00057     \textcolor{keywordtype}{float} size = 800.0;
00058 
00059     \textcolor{comment}{//Simplex noise object}
00060     SimplexNoise* simplex = \textcolor{keyword}{new} SimplexNoise();
00061 
00062     \textcolor{keywordtype}{float} simp         = simplex->fractal(6, x / (2000.0 * size),  y / (2000.0 * size))  * (45.0 * (size / 
      10));
00063     \textcolor{keywordtype}{float} simp2        = simplex->fractal(6, x / (6000.0 * size),  y / (6000.0 * size))  * (60.0 * (size / 
      10));
00064     \textcolor{keywordtype}{float} simp\_small   = simplex->fractal(6, x / (26.0 * size),   y / (26.0 * size))   * (10.0 * (size / 10
      ));
00065     \textcolor{keywordtype}{float} simp\_smaller = simplex->fractal(6, x / (2.0 * size),    y / (2.0 * size))    * (3 * (size / 10));
00066 
00067     simp = (simp + simp2 + simp\_small + simp\_smaller) / 4.0;
00068 
00069     \textcolor{keyword}{delete} simplex;
00070     \textcolor{keywordflow}{return} simp;
00071 \}
00072 
00073 Terrain::Terrain(Camera* camera) \{
00074     currentCamera = camera;
00075     
00076     vec3 position = camera->transform->getPosition();
00077     vec2 location = getTileLocation(position.x, position.z);
00078 
00079     std::cout << \textcolor{stringliteral}{"Creating sector..."} << std::endl;
00080     Sector* sector = \textcolor{keyword}{new} Sector(location.x, location.y, shader, camera);
00081     sectors.push\_back(sector);
00082 \}
00083 
00084 \textcolor{keywordtype}{void} Terrain::render() \{
00085     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < sectors.size(); i++) \{
00086         sectors[i]->render();
00087     \}
00088 \}
00089 
00090 \textcolor{comment}{/*}
00091 \textcolor{comment}{void Terrain() \{}
00092 \textcolor{comment}{    int width = 30; int height = 30;}
00093 \textcolor{comment}{}
00094 \textcolor{comment}{    //Generate simplex array}
00095 \textcolor{comment}{    for (int y = 0; y < height + 10; y++) \{}
00096 \textcolor{comment}{        std::vector<float> row;}
00097 \textcolor{comment}{        for (int x = 0; x < width + 10; x++) \{}
00098 \textcolor{comment}{            row.push\_back(getval(x, y));}
00099 \textcolor{comment}{        \}}
00100 \textcolor{comment}{        simplexArray.push\_back(row);}
00101 \textcolor{comment}{    \}}
00102 \textcolor{comment}{}
00103 \textcolor{comment}{    //Generate vertices from noise}
00104 \textcolor{comment}{    for (int i = 0; i < height; i++) \{}
00105 \textcolor{comment}{        for (int j = 0; j < width; j++) \{}
00106 \textcolor{comment}{            std::vector<float> v = VERT::getTile(}
00107 \textcolor{comment}{                simplexArray[i + 1][j], }
00108 \textcolor{comment}{                simplexArray[i + 1][j + 1],}
00109 \textcolor{comment}{                simplexArray[i][j], }
00110 \textcolor{comment}{                simplexArray[i][j + 1]}
00111 \textcolor{comment}{            );}
00112 \textcolor{comment}{        }
00113 \textcolor{comment}{            for (int l = 0; l < v.size() / 3; l++) \{}
00114 \textcolor{comment}{                int index = l * 3;}
00115 \textcolor{comment}{                v[index] += j;    //.25 seperation}
00116 \textcolor{comment}{                v[index + 2] += i;    //.25 seperation}
00117 \textcolor{comment}{}
00118 \textcolor{comment}{                vertices.push\_back(v[index]);}
00119 \textcolor{comment}{                vertices.push\_back(v[index + 1]);}
00120 \textcolor{comment}{                vertices.push\_back(v[index + 2]);}
00121 \textcolor{comment}{            \}}
00122 \textcolor{comment}{        \}}
00123 \textcolor{comment}{    \}}
00124 \textcolor{comment}{}
00125 \textcolor{comment}{    terrainModel = new Model(vertices, std::vector<float>\{\});}
00126 \textcolor{comment}{}
00127 \textcolor{comment}{    genTrees();}
00128 \textcolor{comment}{\}}
00129 \textcolor{comment}{}
00130 \textcolor{comment}{void Terrain::render(Camera* camera) \{}
00131 \textcolor{comment}{    //Model::render(vertices, shader, new vert3f(.133, .545, .13), glm::mat4(1.0), camera);}
00132 \textcolor{comment}{    terrainModel->render(shader, mat4(1.0), camera);}
00133 \textcolor{comment}{    //treeModel->render(treeShader, mat4(1.0), camera);}
00134 \textcolor{comment}{    //renderTrees(camera);}
00135 \textcolor{comment}{\}}
00136 \textcolor{comment}{void Terrain::genTrees() \{}
00137 \textcolor{comment}{    int width = 1000; int height = 1000;}
00138 \textcolor{comment}{    float seperation = 200.0;}
00139 \textcolor{comment}{}
00140 \textcolor{comment}{    for (int y = 0; y < height; y++) \{}
00141 \textcolor{comment}{        for (int x = 0; x < width; x++) \{}
00142 \textcolor{comment}{            const float val = ((getval(x, y) + 1) / 2.0) / 60.0;}
00143 \textcolor{comment}{            const float ran = (rand() % 100) / 2.0;}
00144 \textcolor{comment}{}
00145 \textcolor{comment}{            if (ran < val) \{}
00146 \textcolor{comment}{                const int x\_val = x + ((rand() % 50) / 10.0);}
00147 \textcolor{comment}{                const int y\_val = y + ((rand() % 50) / 10.0);}
00148 \textcolor{comment}{}
00149 \textcolor{comment}{                //if below water level, skip}
00150 \textcolor{comment}{                if (getval(x\_val, y\_val) < .75) \{}
00151 \textcolor{comment}{                    continue;}
00152 \textcolor{comment}{                \}}
00153 \textcolor{comment}{}
00154 \textcolor{comment}{                std::vector<float> verts = VERT::getCylinder(new vert3f(}
00155 \textcolor{comment}{                    //LOCATION}
00156 \textcolor{comment}{                    x\_val, }
00157 \textcolor{comment}{                    getval(x\_val, y\_val), }
00158 \textcolor{comment}{                    y\_val}
00159 \textcolor{comment}{}
00160 \textcolor{comment}{                ), 15, .37, ((rand() % 10) / 3) + 10);}
00161 \textcolor{comment}{                for (int i = 0; i < verts.size(); i++) \{}
00162 \textcolor{comment}{                    treeVertices.push\_back(verts[i]);}
00163 \textcolor{comment}{                \}}
00164 \textcolor{comment}{            \}}
00165 \textcolor{comment}{        \}}
00166 \textcolor{comment}{    \}}
00167 \textcolor{comment}{}
00168 \textcolor{comment}{    std::cout << "Tree Vertices: " << treeVertices.size() << std::endl;}
00169 \textcolor{comment}{    treeModel = new Model(treeVertices, std::vector<float>\{\});}
00170 \textcolor{comment}{\}}
00171 \textcolor{comment}{}
00172 \textcolor{comment}{void Terrain::renderTrees(Camera* camera) \{}
00173 \textcolor{comment}{    //Model::render(treeVertices, treeShader, new vert3f(.325, .192, .094), mat4(1.0), camera);}
00174 \textcolor{comment}{\}}
00175 \textcolor{comment}{*/}
\end{DoxyCode}
